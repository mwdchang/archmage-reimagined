<template>
  <main v-if="targetSummary">
    <div class="section-header">
      You are {{ battleTypeStr }} {{ targetSummary.name }} (#{{targetSummary.id}}) 
    </div>
    <div class="row" style="margin-bottom: 10px">
      <img src="@/assets/images/battle.png" width="400" class="gen-img" />
    </div>
    <table>
      <tbody>
        <tr>
          <td>Unit</td> 
          <td>Size</td>
          <td>Power</td>
          <td>Power %</td>
          <td> 
            <input type="checkbox" v-model="useAllStacks" v-if="battleType !== 'pillage'"> 
          </td>
        </tr>
        <tr v-for="(stack, _idx) of armySelection" :key="stack.id"
          @click="stack.active = !stack.active">
          <td> 
            <router-link :to="{ name: 'viewUnit', params: { id: stack.id }}"> {{ stack.name }} </router-link>
          </td>
          <td class="text-right"> {{ readbleNumber(stack.size) }} </td>
          <td class="text-right"> {{ readbleNumber(stack.power) }} </td>
          <td class="text-right"> {{ (100 * stack.powerPercentage).toFixed(2) }}% </td>
          <td>
              <input type="checkbox" v-model="stack.active" v-if="battleType !== 'pillage'">
              <input type="radio" :value="stack.id" v-model="pillageStackId" v-if="battleType === 'pillage'">
          </td>
        </tr>
      </tbody>
    </table>

    <br>

    <section class="form">
      <div class="row" style="align-items: baseline" v-if="battleType !== 'pillage'">
        <label style="width:6rem">Spell</label>
        <select v-model="battleSpell">
          <option v-for="spell of battleSpells" :key="spell.id" :value="spell.id">{{ spell.name }}</option>
        </select>
      </div>
      <div class="row" style="align-items: baseline" v-if="battleType !== 'pillage'">
        <label style="width:6rem">Item</label>
        <select v-model="battleItem">
          <option v-for="item of battleItems" :key="item.id" :value="item.id">{{ item.name }}</option>
        </select>
      </div>

      <button 
        v-if="battleType !== 'pillage'"
        @click="doBattle" 
        :disabled="armySelection.filter(d => d.active).length === 0">
        {{ readableStr(battleType) }}
      </button>
      <button 
        v-if="battleType === 'pillage'"
        @click="doBattle" 
        :disabled="pillageStackId === null">
        {{ readableStr(battleType) }}
      </button>
    </section>

    <div v-for="error of errors" class="error">
      {{ error }}
    </div>
  </main>
</template>

<script setup lang="ts">
import { onMounted, ref, computed, watch } from 'vue';
import { useRouter } from 'vue-router';
import { API } from '@/api/api';
import { useMageStore } from '@/stores/mage';
import { 
  getSpells, getItems, getBattleArmy, readbleNumber,
  BattleArmyItem, readableStr
} from '@/util/util';

const mageStore = useMageStore();
const router = useRouter();

const props = defineProps<{ 
  targetId: string,
  battleType: 'siege' | 'regular' | 'pillage' 
}>(); 

const targetSummary = ref<any>(null);
const armySelection = ref<BattleArmyItem[]>([]);
const battleSpell = ref('');
const battleItem = ref('');
const pillageStackId = ref<string|null>(null);

const battleTypeStr = computed(() => {
  if (props.battleType === 'siege') return 'sieging';
  if (props.battleType === 'regular') return 'attacking';
  if (props.battleType === 'pillage') return 'pillaging';
});

const battleSpells = computed(() => {
  const mage = mageStore.mage; 
  if (!mage) return [];

  const result = getSpells(mage).filter(spell => {
    return spell.attributes.includes('battle');
  });

  // Add none option
  const noSpell = {
    id: '',
    magic: '',
    name: 'None',
    castingCost: 0,
    castingTurn: 0,
    attributes: []
  };
  result.unshift(noSpell);

  return result;
});

const battleItems = computed(() => {
  const mage = mageStore.mage; 
  if (!mage) return [];

  const result = getItems(mage).filter(item => {
    return item.attributes.includes('battle');
  });

  // Add none option
  const noItem = {
    id: '',
    name: 'None',
    attributes: [],
    amount: 0
  }
  result.unshift(noItem);

  return result;
});


const useAllStacks = ref(false);
const errors = ref<string[]>([]);

const doBattle = async () => {
  if (!mageStore.mage) return;
  if (!props.targetId || props.targetId === '') return;

  const stackIds = props.battleType === 'pillage' ? 
    [pillageStackId.value] :
    armySelection.value.filter(d => d.active === true).map(d => d.id);

  if (stackIds.length === 0) {
    return;
  }

  const res = await API.post('/war', { 
    targetId: props.targetId,
    battleType: props.battleType,
    spellId: battleSpell.value,
    itemId: battleItem.value,
    stackIds
  });

  // eg: not in range, or insufficient number of turns
  if (res.data.errors.length > 0) {
    errors.value = res.data.errors;
    return;
  }

  if (res.data.reportId) {
    mageStore.setMage(res.data.mage);
    router.push({
      name: 'battleResult',
      params: {
        id: res.data.reportId
      }
    });
  }
};


onMounted(async () => {
  // Resolve target
  const res = await API.get(`/mage/${props.targetId}`);
  targetSummary.value = res.data.mageSummary;

  if (!mageStore.mage) return;

  // Resolve army
  const rawArmy = getBattleArmy(mageStore.mage);
  armySelection.value = rawArmy.sort((a, b) => b.power - a.power);
});

watch(
  () => useAllStacks.value,
  () => {
    armySelection.value.forEach(d => {
      d.active = useAllStacks.value;
    });
  },
  { immediate: true }
);

</script>
